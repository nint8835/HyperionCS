/**
 * Generated by @openapi-codegen
 *
 * @version 0.1.0
 */
import * as reactQuery from '@tanstack/react-query';

import { type InternalContext, queryKeyFn, useInternalContext } from './internalContext';
import type * as Fetcher from './internalFetcher';
import { internalFetch } from './internalFetcher';
import type * as Schemas from './internalSchemas';
import { deepMerge } from './internalUtils';

type QueryFnOptions = {
  signal?: AbortController['signal'];
};

export type GetCurrentUserError = Fetcher.ErrorWrapper<undefined>;

export type GetCurrentUserResponse = Schemas.SessionUser | null;

export type GetCurrentUserVariables = InternalContext['fetcherOptions'];

/**
 * Retrieve the details of the current user.
 */
export const fetchGetCurrentUser = (variables: GetCurrentUserVariables, signal?: AbortSignal) =>
  internalFetch<GetCurrentUserResponse, GetCurrentUserError, undefined, {}, {}, {}>({
    url: '/auth/me',
    method: 'get',
    ...variables,
    signal,
  });

/**
 * Retrieve the details of the current user.
 */
export function getCurrentUserQuery(variables: GetCurrentUserVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetCurrentUserResponse>;
};

export function getCurrentUserQuery(variables: GetCurrentUserVariables | reactQuery.SkipToken): {
  queryKey: reactQuery.QueryKey;
  queryFn: ((options: QueryFnOptions) => Promise<GetCurrentUserResponse>) | reactQuery.SkipToken;
};

export function getCurrentUserQuery(variables: GetCurrentUserVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: '/auth/me',
      operationId: 'getCurrentUser',
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetCurrentUser(variables, signal),
  };
}

/**
 * Retrieve the details of the current user.
 */
export const useSuspenseGetCurrentUser = <TData = GetCurrentUserResponse>(
  variables: GetCurrentUserVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetCurrentUserResponse, GetCurrentUserError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useInternalContext(options);
  return reactQuery.useSuspenseQuery<GetCurrentUserResponse, GetCurrentUserError, TData>({
    ...getCurrentUserQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Retrieve the details of the current user.
 */
export const useGetCurrentUser = <TData = GetCurrentUserResponse>(
  variables: GetCurrentUserVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<GetCurrentUserResponse, GetCurrentUserError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useInternalContext(options);
  return reactQuery.useQuery<GetCurrentUserResponse, GetCurrentUserError, TData>({
    ...getCurrentUserQuery(variables === reactQuery.skipToken ? variables : deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export type CreateCurrencyError = Fetcher.ErrorWrapper<
  | {
      status: 409;
      payload: Schemas.ErrorResponseSchema;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type CreateCurrencyVariables = {
  body: Schemas.CreateCurrencySchema;
} & InternalContext['fetcherOptions'];

/**
 * Create a new currency.
 */
export const fetchCreateCurrency = (variables: CreateCurrencyVariables, signal?: AbortSignal) =>
  internalFetch<Schemas.CurrencySchema, CreateCurrencyError, Schemas.CreateCurrencySchema, {}, {}, {}>({
    url: '/api/internal/currencies/',
    method: 'post',
    ...variables,
    signal,
  });

/**
 * Create a new currency.
 */
export const useCreateCurrency = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.CurrencySchema, CreateCurrencyError, CreateCurrencyVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useInternalContext();
  return reactQuery.useMutation<Schemas.CurrencySchema, CreateCurrencyError, CreateCurrencyVariables>({
    mutationFn: (variables: CreateCurrencyVariables) => fetchCreateCurrency(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type EditCurrencyPathParams = {
  shortcode: string;
};

export type EditCurrencyError = Fetcher.ErrorWrapper<
  | {
      status: 403;
      payload: Schemas.ErrorResponseSchema;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type EditCurrencyVariables = {
  body: Schemas.EditCurrencySchema;
  pathParams: EditCurrencyPathParams;
} & InternalContext['fetcherOptions'];

/**
 * Edit an existing currency.
 */
export const fetchEditCurrency = (variables: EditCurrencyVariables, signal?: AbortSignal) =>
  internalFetch<Schemas.CurrencySchema, EditCurrencyError, Schemas.EditCurrencySchema, {}, {}, EditCurrencyPathParams>({
    url: '/api/internal/currencies/{shortcode}',
    method: 'patch',
    ...variables,
    signal,
  });

/**
 * Edit an existing currency.
 */
export const useEditCurrency = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.CurrencySchema, EditCurrencyError, EditCurrencyVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useInternalContext();
  return reactQuery.useMutation<Schemas.CurrencySchema, EditCurrencyError, EditCurrencyVariables>({
    mutationFn: (variables: EditCurrencyVariables) => fetchEditCurrency(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetCurrencyPermissionsPathParams = {
  shortcode: string;
};

export type GetCurrencyPermissionsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCurrencyPermissionsVariables = {
  pathParams: GetCurrencyPermissionsPathParams;
} & InternalContext['fetcherOptions'];

/**
 * Get the permissions the current user has on a given currency.
 */
export const fetchGetCurrencyPermissions = (variables: GetCurrencyPermissionsVariables, signal?: AbortSignal) =>
  internalFetch<
    Schemas.CurrencyPermissionsSchema,
    GetCurrencyPermissionsError,
    undefined,
    {},
    {},
    GetCurrencyPermissionsPathParams
  >({
    url: '/api/internal/currencies/{shortcode}/permissions',
    method: 'get',
    ...variables,
    signal,
  });

/**
 * Get the permissions the current user has on a given currency.
 */
export function getCurrencyPermissionsQuery(variables: GetCurrencyPermissionsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.CurrencyPermissionsSchema>;
};

export function getCurrencyPermissionsQuery(variables: GetCurrencyPermissionsVariables | reactQuery.SkipToken): {
  queryKey: reactQuery.QueryKey;
  queryFn: ((options: QueryFnOptions) => Promise<Schemas.CurrencyPermissionsSchema>) | reactQuery.SkipToken;
};

export function getCurrencyPermissionsQuery(variables: GetCurrencyPermissionsVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: '/api/internal/currencies/{shortcode}/permissions',
      operationId: 'getCurrencyPermissions',
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetCurrencyPermissions(variables, signal),
  };
}

/**
 * Get the permissions the current user has on a given currency.
 */
export const useSuspenseGetCurrencyPermissions = <TData = Schemas.CurrencyPermissionsSchema>(
  variables: GetCurrencyPermissionsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.CurrencyPermissionsSchema, GetCurrencyPermissionsError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useInternalContext(options);
  return reactQuery.useSuspenseQuery<Schemas.CurrencyPermissionsSchema, GetCurrencyPermissionsError, TData>({
    ...getCurrencyPermissionsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get the permissions the current user has on a given currency.
 */
export const useGetCurrencyPermissions = <TData = Schemas.CurrencyPermissionsSchema>(
  variables: GetCurrencyPermissionsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.CurrencyPermissionsSchema, GetCurrencyPermissionsError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useInternalContext(options);
  return reactQuery.useQuery<Schemas.CurrencyPermissionsSchema, GetCurrencyPermissionsError, TData>({
    ...getCurrencyPermissionsQuery(
      variables === reactQuery.skipToken ? variables : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type ListIntegrationsError = Fetcher.ErrorWrapper<undefined>;

export type ListIntegrationsResponse = Schemas.IntegrationSchema[];

export type ListIntegrationsVariables = InternalContext['fetcherOptions'];

/**
 * List all integrations the current user has access to.
 */
export const fetchListIntegrations = (variables: ListIntegrationsVariables, signal?: AbortSignal) =>
  internalFetch<ListIntegrationsResponse, ListIntegrationsError, undefined, {}, {}, {}>({
    url: '/api/internal/integrations/',
    method: 'get',
    ...variables,
    signal,
  });

/**
 * List all integrations the current user has access to.
 */
export function listIntegrationsQuery(variables: ListIntegrationsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<ListIntegrationsResponse>;
};

export function listIntegrationsQuery(variables: ListIntegrationsVariables | reactQuery.SkipToken): {
  queryKey: reactQuery.QueryKey;
  queryFn: ((options: QueryFnOptions) => Promise<ListIntegrationsResponse>) | reactQuery.SkipToken;
};

export function listIntegrationsQuery(variables: ListIntegrationsVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: '/api/internal/integrations/',
      operationId: 'listIntegrations',
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchListIntegrations(variables, signal),
  };
}

/**
 * List all integrations the current user has access to.
 */
export const useSuspenseListIntegrations = <TData = ListIntegrationsResponse>(
  variables: ListIntegrationsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<ListIntegrationsResponse, ListIntegrationsError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useInternalContext(options);
  return reactQuery.useSuspenseQuery<ListIntegrationsResponse, ListIntegrationsError, TData>({
    ...listIntegrationsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * List all integrations the current user has access to.
 */
export const useListIntegrations = <TData = ListIntegrationsResponse>(
  variables: ListIntegrationsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<ListIntegrationsResponse, ListIntegrationsError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useInternalContext(options);
  return reactQuery.useQuery<ListIntegrationsResponse, ListIntegrationsError, TData>({
    ...listIntegrationsQuery(variables === reactQuery.skipToken ? variables : deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export type CreateIntegrationError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type CreateIntegrationVariables = {
  body: Schemas.CreateIntegrationSchema;
} & InternalContext['fetcherOptions'];

/**
 * Create a new integration.
 */
export const fetchCreateIntegration = (variables: CreateIntegrationVariables, signal?: AbortSignal) =>
  internalFetch<Schemas.IntegrationSchema, CreateIntegrationError, Schemas.CreateIntegrationSchema, {}, {}, {}>({
    url: '/api/internal/integrations/',
    method: 'post',
    ...variables,
    signal,
  });

/**
 * Create a new integration.
 */
export const useCreateIntegration = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.IntegrationSchema, CreateIntegrationError, CreateIntegrationVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useInternalContext();
  return reactQuery.useMutation<Schemas.IntegrationSchema, CreateIntegrationError, CreateIntegrationVariables>({
    mutationFn: (variables: CreateIntegrationVariables) => fetchCreateIntegration(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ConnectIntegrationPathParams = {
  integrationId: string;
};

export type ConnectIntegrationError = Fetcher.ErrorWrapper<
  | {
      status: 403;
      payload: Schemas.ErrorResponseSchema;
    }
  | {
      status: 409;
      payload: Schemas.ErrorResponseSchema;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type ConnectIntegrationVariables = {
  body: Schemas.ConnectIntegrationSchema;
  pathParams: ConnectIntegrationPathParams;
} & InternalContext['fetcherOptions'];

/**
 * Connect an integration to a currency.
 */
export const fetchConnectIntegration = (variables: ConnectIntegrationVariables, signal?: AbortSignal) =>
  internalFetch<void, ConnectIntegrationError, Schemas.ConnectIntegrationSchema, {}, {}, ConnectIntegrationPathParams>({
    url: '/api/internal/integrations/{integrationId}/connect',
    method: 'post',
    ...variables,
    signal,
  });

/**
 * Connect an integration to a currency.
 */
export const useConnectIntegration = (
  options?: Omit<
    reactQuery.UseMutationOptions<void, ConnectIntegrationError, ConnectIntegrationVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useInternalContext();
  return reactQuery.useMutation<void, ConnectIntegrationError, ConnectIntegrationVariables>({
    mutationFn: (variables: ConnectIntegrationVariables) =>
      fetchConnectIntegration(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DisconnectIntegrationPathParams = {
  integrationId: string;
};

export type DisconnectIntegrationError = Fetcher.ErrorWrapper<
  | {
      status: 403;
      payload: Schemas.ErrorResponseSchema;
    }
  | {
      status: 409;
      payload: Schemas.ErrorResponseSchema;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type DisconnectIntegrationVariables = {
  body: Schemas.ConnectIntegrationSchema;
  pathParams: DisconnectIntegrationPathParams;
} & InternalContext['fetcherOptions'];

/**
 * Disconnect an integration from a currency.
 */
export const fetchDisconnectIntegration = (variables: DisconnectIntegrationVariables, signal?: AbortSignal) =>
  internalFetch<
    undefined,
    DisconnectIntegrationError,
    Schemas.ConnectIntegrationSchema,
    {},
    {},
    DisconnectIntegrationPathParams
  >({
    url: '/api/internal/integrations/{integrationId}/disconnect',
    method: 'post',
    ...variables,
    signal,
  });

/**
 * Disconnect an integration from a currency.
 */
export const useDisconnectIntegration = (
  options?: Omit<
    reactQuery.UseMutationOptions<undefined, DisconnectIntegrationError, DisconnectIntegrationVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useInternalContext();
  return reactQuery.useMutation<undefined, DisconnectIntegrationError, DisconnectIntegrationVariables>({
    mutationFn: (variables: DisconnectIntegrationVariables) =>
      fetchDisconnectIntegration(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type QueryOperation =
  | {
      path: '/auth/me';
      operationId: 'getCurrentUser';
      variables: GetCurrentUserVariables | reactQuery.SkipToken;
    }
  | {
      path: '/api/internal/currencies/{shortcode}/permissions';
      operationId: 'getCurrencyPermissions';
      variables: GetCurrencyPermissionsVariables | reactQuery.SkipToken;
    }
  | {
      path: '/api/internal/integrations/';
      operationId: 'listIntegrations';
      variables: ListIntegrationsVariables | reactQuery.SkipToken;
    };
