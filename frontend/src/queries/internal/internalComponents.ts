/**
 * Generated by @openapi-codegen
 *
 * @version 0.1.0
 */
import * as reactQuery from '@tanstack/react-query';

import { InternalContext, queryKeyFn, useInternalContext } from './internalContext';
import type * as Fetcher from './internalFetcher';
import { internalFetch } from './internalFetcher';
import type * as Schemas from './internalSchemas';
import { deepMerge } from './internalUtils';

type QueryFnOptions = {
  signal?: AbortController['signal'];
};

export type PlaceholderEndpointError = Fetcher.ErrorWrapper<undefined>;

export type PlaceholderEndpointVariables = InternalContext['fetcherOptions'];

export const fetchPlaceholderEndpoint = (variables: PlaceholderEndpointVariables, signal?: AbortSignal) =>
  internalFetch<Schemas.PlaceholderSchema, PlaceholderEndpointError, undefined, {}, {}, {}>({
    url: '/placeholder',
    method: 'get',
    ...variables,
    signal,
  });

export function placeholderEndpointQuery(variables: PlaceholderEndpointVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.PlaceholderSchema>;
};

export function placeholderEndpointQuery(variables: PlaceholderEndpointVariables | reactQuery.SkipToken): {
  queryKey: reactQuery.QueryKey;
  queryFn: ((options: QueryFnOptions) => Promise<Schemas.PlaceholderSchema>) | reactQuery.SkipToken;
};

export function placeholderEndpointQuery(variables: PlaceholderEndpointVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: '/placeholder',
      operationId: 'placeholderEndpoint',
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchPlaceholderEndpoint(variables, signal),
  };
}

export const useSuspensePlaceholderEndpoint = <TData = Schemas.PlaceholderSchema>(
  variables: PlaceholderEndpointVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.PlaceholderSchema, PlaceholderEndpointError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useInternalContext(options);
  return reactQuery.useSuspenseQuery<Schemas.PlaceholderSchema, PlaceholderEndpointError, TData>({
    ...placeholderEndpointQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const usePlaceholderEndpoint = <TData = Schemas.PlaceholderSchema>(
  variables: PlaceholderEndpointVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.PlaceholderSchema, PlaceholderEndpointError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useInternalContext(options);
  return reactQuery.useQuery<Schemas.PlaceholderSchema, PlaceholderEndpointError, TData>({
    ...placeholderEndpointQuery(variables === reactQuery.skipToken ? variables : deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export type QueryOperation = {
  path: '/placeholder';
  operationId: 'placeholderEndpoint';
  variables: PlaceholderEndpointVariables | reactQuery.SkipToken;
};
